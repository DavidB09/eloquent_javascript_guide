<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Eloquent JavaScript practice guide for chapter exercises and examples">
    <meta name="author" content="David Brunner">
    <meta name="keywords" content="JavaScript, Eloquent JavaScript, Chapter 19, Exercises">
    <meta name="description" content="Solutions and explanations for exercises in Chapter 19 of Eloquent JavaScript.">
    <title>Eloquent JavaScript - Chapter 19</title>

    <link href="../style.css" rel="stylesheet">
    <link href="../assets/css/prism.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=PT+Mono&display=swap" rel="stylesheet"> 
</head>

<body>

    <header>
        <h1>Chapter 19, "A Pixel Art Editor"</h1>

        <div class="header-navigation-links">
            <a href="../chap18/index.html" alt="Chapter 18 Link" title="Chapter 18">Previous</a>
            <a href="../chap20/index.html" alt="Chapter 20 Link" title="Chapter 20">Next</a>
        </div>
    </header>

    <main>

        <article class="container-exercise-problems">

            <section class="exercise-panel">
                <div class="exercise-header"><h2>Keyboard Bindings</h2></div>

                <div class="exercise-body">
                    <h3>Question</h3>

                    <p>Add keyboard shortcuts to the application. The first letter of a tool’s name selects the tool, and <code>control-Z</code> or <code>command-Z</code> activates undo.</p>

                    <p>Do this by modifying the <code>PixelEditor</code> component. Add a <code>tabIndex</code> property of 0 to the wrapping <code>&gt;div></code> element so that it can receive keyboard focus. Note that the property corresponding to the <code>tabindex</code> attribute is called <code>tabIndex</code>, with a capital I, and our <code>elt</code> function expects property names. Register the key event handlers directly on that element. This means you have to click, touch, or tab to the application before you can interact with it with the keyboard.</p>

                    <p>Remember that keyboard events have <code>ctrlKey</code> and <code>metaKey</code> (for the <code>COMMAND</code> key on Mac) properties that you can use to see whether those keys are held down.</p>
                </div>

                <div class="exercise-body">
                    <h3>Personal Answer</h3>

                    <pre id="code1" class="line-numbers linkable-line-numbers language-javascript" tabindex="0" data-line="0"><code class="language-javascript">class PixelEditor {
    constructor(state, config) {
        let {tools, controls, dispatch} = config;
        this.state = state;
        
        this.canvas = new PictureCanvas(state.picture, pos => {
            let tool = tools[this.state.tool];
            let onMove = tool(pos, this.state, dispatch);
            if (onMove) {
                return pos => onMove(pos, this.state, dispatch);
            }
        });
        this.controls = controls.map(Control => new Control(state, config));
        this.dom = elt("div", 
                        {
                            tabIndex: 0, 
                            onkeydown: event => {
                                    if ((event.ctrlKey || event.metaKey) && event.key == 'z')
                                        dispatch({undo: true}); 
                                    else if (!event.ctrlKey && !event.metaKey && !event.altKey) {
                                        for (let toolName in tools) {
                                            if (event.key == toolName[0]) 
                                                dispatch({tool: toolName}); 
                                        }
                                    }
                            }
                        }, 
                        this.canvas.dom, elt("br"), ...this.controls.reduce((a, c) => a.concat(" ", c.dom), []));
    }
    syncState(state) {
        this.state = state;
        this.canvas.syncState(state.picture);
        for (let ctrl of this.controls) ctrl.syncState(state);
    }
}                   </code></pre>
                </div>

                <div class="exercise-body exercise-desc">
                    <p><code class="desc desc-code1" data-line="1">Line 1</code> defines the <code>array</code> method within the <code>topScope</code> object that destructures the values provided by its parameter.</p>

                </div>

                <div class="exercise-body">
                    <h3>Author's Answer</h3>

                    <pre id="code2" class="line-numbers linkable-line-numbers language-javascript" tabindex="0" data-line="0"><code class="language-javascript">class PixelEditor {
    constructor(state, config) {
        let {tools, controls, dispatch} = config;
        this.state = state;

        this.canvas = new PictureCanvas(state.picture, pos => {
            let tool = tools[this.state.tool];
            let onMove = tool(pos, this.state, dispatch);
            if (onMove) {
                return pos => onMove(pos, this.state, dispatch);
            }
        });
        this.controls = controls.map(Control => new Control(state, config));
        this.dom = elt("div", {
            tabIndex: 0,
            onkeydown: event => this.keyDown(event, config)
        }, this.canvas.dom, elt("br"), ...this.controls.reduce((a, c) => a.concat(" ", c.dom), []));
    }
    keyDown(event, config) {
        if (event.key == "z" && (event.ctrlKey || event.metaKey)) {
            event.preventDefault();
            config.dispatch({undo: true});
        } else if (!event.ctrlKey && !event.metaKey && !event.altKey) {
            for (let tool of Object.keys(config.tools)) {
                if (tool[0] == event.key) {
                    event.preventDefault();
                    config.dispatch({tool});
                    return;
                }
            }
        }
    }
    syncState(state) {
        this.state = state;
        this.canvas.syncState(state.picture);
        for (let ctrl of this.controls) ctrl.syncState(state);
    }
}                   </code></pre>
                </div>

                <div class="exercise-body">
                    <p>The author used the same logic just expressed in more concise code.</p>
                </div>

                <button class="exercise-body exercise-close">⇮</button>
            </section>

            <section class="exercise-panel">
                <div class="exercise-header"><h2>Efficient Drawing</h2></div>

                <div class="exercise-body">
                    <h3>Question</h3>

                    <p>During drawing, the majority of work that our application does happens in <code>drawPicture</code>. Creating a new state and updating the rest of the DOM isn’t very expensive, but repainting all the pixels on the canvas is quite a bit of work.</p>

                    <p>Find a way to make the <code>syncState</code> method of <code>PictureCanvas</code> faster by redrawing only the pixels that actually changed.</p>

                    <p>Remember that <code>drawPicture</code> is also used by the save button, so if you change it, either make sure the changes don’t break the old use or create a new version with a different name.</p>

                    <p>Also note that changing the size of a <code>&lt;canvas></code> element, by setting its <code>width</code> or <code>height</code> properties, clears it, making it entirely transparent again.</p> 
                </div>

                <div class="exercise-body">
                    <h3>Personal Answer</h3>

                    <pre id="code3" class="line-numbers linkable-line-numbers language-javascript" tabindex="0" data-line="0"><code class="language-javascript">PictureCanvas.prototype.syncState = function(newPicture) {
    if (this.picture == newPicture) return;
    drawPicture(newPicture, this.dom, scale, this.picture);
    this.picture = newPicture; 
};

function drawPicture(newPicture, canvas, scale, oldPicture) {
    if (newPicture.width != oldPicture?.width) canvas.width = newPicture.width * scale;
    if (newPicture.height != oldPicture?.height) canvas.height = newPicture.height * scale;
    let cx = canvas.getContext("2d");

    for (let y = 0; y < newPicture.height; y++) {
        for (let x = 0; x < newPicture.width; x++) {
            let currNewPixel = newPicture.pixel(x, y); 
            if (currNewPixel != oldPicture?.pixel(x, y)) {
                cx.fillStyle = currNewPixel;
                cx.fillRect(x * scale, y * scale, scale, scale);
            }
        }
    }
}                   </code></pre>
                </div>

                <div class="exercise-body">

                </div>

                <div class="exercise-body">
                    <h3>Author's Answer</h3>

                    <pre id="code4" class="line-numbers linkable-line-numbers language-javascript" tabindex="0" data-line="0"><code class="language-javascript">PictureCanvas.prototype.syncState = function(picture) {
    if (this.picture == picture) return;
    drawPicture(picture, this.dom, scale, this.picture);
    this.picture = picture;
}

function drawPicture(picture, canvas, scale, previous) {
    if (previous == null || previous.width != picture.width || previous.height != picture.height) {
        canvas.width = picture.width * scale;
        canvas.height = picture.height * scale;
        previous = null;
    }

    let cx = canvas.getContext("2d");
    for (let y = 0; y < picture.height; y++) {
        for (let x = 0; x < picture.width; x++) {
            let color = picture.pixel(x, y);
            if (previous == null || previous.pixel(x, y) != color) {
                cx.fillStyle = color;
                cx.fillRect(x * scale, y * scale, scale, scale);
            }
        }
    }
}                   </code></pre>
                </div>

                <div class="exercise-body">
                    
                </div>

                <button class="exercise-body exercise-close">⇮</button>
            </section>

            <section class="exercise-panel">
                <div class="exercise-header"><h2>Circles</h2></div>

                <div class="exercise-body">
                    <h3>Question</h3>

                    <p>Define a tool called <code>circle</code> that draws a filled circle when you drag. The center of the circle lies at the point where the drag or touch gesture starts, and its radius is determined by the distance dragged.</p> 
                </div>

                <div class="exercise-body">
                    <h3>Personal Answer</h3>

                    <pre id="code5" class="line-numbers linkable-line-numbers language-javascript" tabindex="0" data-line="0"><code class="language-javascript">function circle(center, state, dispatch) {
    function drawCircle(endpoint) {
        let radius = Math.sqrt(Math.pow(endpoint.x - center.x, 2) + Math.pow(endpoint.y - center.y, 2)); 

        let drawn = [];
        for (let y = center.y - Math.floor(radius); y <= center.y + Math.ceil(radius); y++) {
            for (let x = center.x - Math.floor(radius); x <= center.x + Math.ceil(radius); x++) {
                if (y < 0 || x < 0 || x >= state.picture.width || y >= state.picture.height) continue; 
                if (Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2)) <= radius) {
                    drawn.push({x, y, color: state.color});
                }
            }
        }

        dispatch({picture: state.picture.draw(drawn)});
    }
    drawCircle(center);
    return drawCircle;
}                   </code></pre>
                </div>

                <div class="exercise-body exercise-desc">
                    <p><code class="desc desc-code5" data-line="1">Line 1</code> defines the <code>set</code> method found within the <code>specialForms</code> object with the <code>args</code> and <code>scope</code> parameters.</p>

                </div>

                <div class="exercise-body">
                    <h3>Author's Answer</h3>

                    <pre id="code6" class="line-numbers linkable-line-numbers language-javascript" tabindex="0" data-line="0"><code class="language-javascript">function circle(pos, state, dispatch) {
    function drawCircle(to) {
        let radius = Math.sqrt(Math.pow(to.x - pos.x, 2) + Math.pow(to.y - pos.y, 2));
        let radiusC = Math.ceil(radius);
        let drawn = [];
        for (let dy = -radiusC; dy <= radiusC; dy++) {
            for (let dx = -radiusC; dx <= radiusC; dx++) {
                let dist = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
                if (dist > radius) continue;
                let y = pos.y + dy, x = pos.x + dx;
                if (y < 0 || y >= state.picture.height || x < 0 || x >= state.picture.width) continue;
                drawn.push({x, y, color: state.color});
            }
        }
        dispatch({picture: state.picture.draw(drawn)});
    }
    drawCircle(pos);
    return drawCircle;
}                   </code></pre>
                </div>

                <div class="exercise-body exercise-desc">
                    <p><code class="desc desc-code6" data-line="1">Line 1</code> defines the <code>set</code> method found within the <code>specialForms</code> object with the <code>args</code> and <code>env</code> parameters.</p>

                </div>

                <button class="exercise-body exercise-close">⇮</button>
            </section>

            <section class="exercise-panel">
                <div class="exercise-header"><h2>Proper Lines</h2></div>

                <div class="exercise-body">
                    <h3>Question</h3>

                    <p>On most browsers, when you select the <code>draw</code> tool and quickly drag across the picture, you don’t get a closed line. Rather, you get dots with gaps between them because the <code>"mousemove"</code> or <code>"touchmove"</code> events did not fire quickly enough to hit every pixel.</p>

                    <p>Improve the <code>draw</code> tool to make it draw a full line. This means you have to make the motion handler function remember the previous position and connect that to the current one.</p>

                    <p>To do this, since the pixels can be an arbitrary distance apart, you’ll have to write a general line drawing function.</p>

                    <p>A line between two pixels is a connected chain of pixels, as straight as possible, going from the start to the end. Diagonally adjacent pixels count as a connected.</p> 

                    <p>Finally, if we have code that draws a line between two arbitrary points, we might as well use it to also define a <code>line</code> tool, which draws a straight line between the start and end of a drag.</p>
                </div>

                <div class="exercise-body">
                    <h3>Personal Answer</h3>

                    <pre id="code7" class="line-numbers linkable-line-numbers language-javascript" tabindex="0" data-line="0"><code class="language-javascript">function draw(pos, state, dispatch) {
    let oldPos = pos; 
    
    function drawPixel({x, y}, state) {
        dispatch({picture: state.picture.draw(findLine(oldPos, {x, y}, state.color))});
        oldPos = {x, y}; 
    }
    drawPixel(pos, state);
    return drawPixel;
}

function findLine(start, end, color) {
    const move = {
        'right': {x: 1}, 
        'left': {x: -1}, 
        'up': {y: -1}, 
        'down': {y: 1}, 
        'equal': {x: 0, y: 0}, 
    }; 

    const findAngle = (opp, adj) => {
        let tanAngle = Math.atan(opp / adj) * (180 / Math.PI); 
        return !isFinite(tanAngle) ? 0 : tanAngle 
    }; 

    let mainAngle = findAngle(Math.abs(end.y - start.y), Math.abs(end.x - start.x)); 

    let linePoints = [{point: start, line: []}]; 
    for (let i = 0; i < linePoints.length; i++) {
        let {point, line} = linePoints[i]; 

        let xMove = point.x < end.x ? 'right' : point.x > end.x ? 'left' : 'equal'; 
        let yMove = point.y < end.y ? 'down' : point.y > end.y ? 'up' : 'equal'; 

        let newPoint = ['p1', 'p2', 'p3'].reduce((init, curr, i) => {
            if (i == 0) return init; 

            curr = {x: point.x + move[i == 1 ? xMove : 'equal'].x, y: point.y + move[i == 1 ? 'equal' : yMove].y, color};  

            let currAngle = findAngle(Math.abs(curr.y - start.y), Math.abs(curr.x - start.x));
            let initAngle = findAngle(Math.abs(init.y - start.y), Math.abs(init.x - start.x)); 

            return Math.abs(currAngle - mainAngle) < Math.abs(initAngle - mainAngle) ? curr : init;
        }, {x: point.x + move[xMove].x, y: point.y + move[yMove].y, color});   

        if (newPoint.x == end.x && newPoint.y == end.y) return line.concat(newPoint); 

        linePoints.push({point: newPoint, line: line.concat(newPoint)});
    }
}

function line(pos, state, dispatch) {
    function drawLine(endpoint) {
        let drawn = [{...pos, color: state.color}, ...findLine(pos, endpoint, state.color)]; 
        dispatch({picture: state.picture.draw(drawn)});
    }
    drawLine(pos);
    return drawLine;
}                   </code></pre>
                </div>

                <div class="exercise-body exercise-desc">
                    <p><code class="desc desc-code7" data-line="1">Line 1</code> defines the <code>set</code> method found within the <code>specialForms</code> object with the <code>args</code> and <code>scope</code> parameters.</p>

                </div>

                <div class="exercise-body">
                    <h3>Author's Answer</h3>

                    <pre id="code8" class="line-numbers linkable-line-numbers language-javascript" tabindex="0" data-line="0"><code class="language-javascript">function drawLine(from, to, color) {
    let points = [];
    if (Math.abs(from.x - to.x) > Math.abs(from.y - to.y)) {
        if (from.x > to.x) [from, to] = [to, from];
        let slope = (to.y - from.y) / (to.x - from.x);
        for (let {x, y} = from; x <= to.x; x++) {
            points.push({x, y: Math.round(y), color});
            y += slope;
        }
    } else {
        if (from.y > to.y) [from, to] = [to, from];
        let slope = (to.x - from.x) / (to.y - from.y);
        for (let {x, y} = from; y <= to.y; y++) {
            points.push({x: Math.round(x), y, color});
            x += slope;
        }
    }
    return points;
}

function draw(pos, state, dispatch) {
    function connect(newPos, state) {
        let line = drawLine(pos, newPos, state.color);
        pos = newPos;
        dispatch({picture: state.picture.draw(line)});
    }
    connect(pos, state);
    return connect;
}

function line(pos, state, dispatch) {
    return end => {
        let line = drawLine(pos, end, state.color);
        dispatch({picture: state.picture.draw(line)});
    };
}                   </code></pre>
                </div>

                <div class="exercise-body exercise-desc">
                    <p><code class="desc desc-code8" data-line="1">Line 1</code> defines the <code>set</code> method found within the <code>specialForms</code> object with the <code>args</code> and <code>env</code> parameters.</p>
                </div>

                <button class="exercise-body exercise-close">⇮</button>
            </section>

        </article>

        <article class="container-navbar">

            <section>

                <h3>3rd Edition</h3>

                <nav>
                    <ul>
                        <li><a href="../intro/index.html" alt="Intro Link" title="Intro">Intro</a></li>
                        <li><a href="../chap1/index.html" alt="Chapter 1 Link" title="Chapter 1">Chapter 1 (Part 1: Language)</a></li>
                        <li><a href="../chap2/index.html" alt="Chapter 2 Link" title="Chapter 2">Chapter 2</a></li>
                        <li><a href="../chap3/index.html" alt="Chapter 3 Link" title="Chapter 3">Chapter 3</a></li>
                        <li><a href="../chap4/index.html" alt="Chapter 4 Link" title="Chapter 4">Chapter 4</a></li>
                        <li><a href="../chap5/index.html" alt="Chapter 5 Link" title="Chapter 5">Chapter 5</a></li>
                        <li><a href="../chap6/index.html" alt="Chapter 6 Link" title="Chapter 6">Chapter 6</a></li>
                        <li><a href="../chap7/index.html" alt="Chapter 7 Link" title="Chapter 7">Chapter 7</a></li>
                        <li><a href="../chap8/index.html" alt="Chapter 8 Link" title="Chapter 8">Chapter 8</a></li>
                        <li><a href="../chap9/index.html" alt="Chapter 9 Link" title="Chapter 9">Chapter 9</a></li>
                        <li><a href="../chap10/index.html" alt="Chapter 10 Link" title="Chapter 10">Chapter 10</a></li>
                    </ul>
                    <ul>
                        <li><a href="../chap11/index.html" alt="Chapter 11 Link" title="Chapter 11">Chapter 11</a></li>
                        <li><a href="../chap12/index.html" alt="Chapter 12 Link" title="Chapter 12">Chapter 12</a></li>
                        <li><a href="../chap13/index.html" alt="Chapter 13 Link" title="Chapter 13">Chapter 13 (Part 2: Browser)</a></li>
                        <li><a href="../chap14/index.html" alt="Chapter 14 Link" title="Chapter 14">Chapter 14</a></li>
                        <li><a href="../chap15/index.html" alt="Chapter 15 Link" title="Chapter 15">Chapter 15</a></li>
                        <li><a href="../chap16/index.html" alt="Chapter 16 Link" title="Chapter 16">Chapter 16</a></li>
                        <li><a href="../chap17/index.html" alt="Chapter 17 Link" title="Chapter 17">Chapter 17</a></li>
                        <li><a href="../chap18/index.html" alt="Chapter 18 Link" title="Chapter 18">Chapter 18</a></li>
                        <li><a href="../chap19/index.html" alt="Chapter 19 Link" title="Chapter 19">Chapter 19</a></li>
                        <li><a href="../chap20/index.html" alt="Chapter 20 Link" title="Chapter 20">Chapter 20 (Part 3: Node)</a></li>
                        <li><a href="../chap21/index.html" alt="Chapter 21 Link" title="Chapter 21">Chapter 21</a></li>
                    </ul>
                </nav>

            </section>

        </article>

    </main>

    <script src="../script.js"></script>
    <script src="../assets/js/prism.js"></script>

</body>

</html>